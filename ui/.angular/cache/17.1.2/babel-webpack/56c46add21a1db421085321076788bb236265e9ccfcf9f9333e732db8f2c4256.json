{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"ngx-cookie-service\";\nimport * as i2 from \"@angular/router\";\nimport * as i3 from \"./products.service\";\n/**\n * Service for managing the user's basket.\n */\nexport let BasketService = /*#__PURE__*/(() => {\n  class BasketService {\n    constructor(cookieService, router, productsService) {\n      this.cookieService = cookieService;\n      this.router = router;\n      this.productsService = productsService;\n      this.addToCartSubject = new Subject();\n      this.cookieName = 'basket-cookie';\n      this.cookieExpiryDays = 365;\n      this.refreshBasketFromCookie();\n    }\n    /**\n     * Get the basket.\n     */\n    getBasket() {\n      this.refreshBasketFromCookie();\n      return this.basket;\n    }\n    /**\n     * Refresh the basket contents from the cookie.\n     */\n    refreshBasketFromCookie() {\n      this.basket = this.getBasketFromCookie();\n    }\n    /**\n     * Call this to trigger the add to cart event has been fired.\n     */\n    emitAddToCartEvent() {\n      this.addToCartSubject.next(true);\n    }\n    /**\n     * Returns an Observable that emits events when an item is added to the cart.\n     * Subscribers to this stream can react accordingly to update the cart.\n     *\n     * @return An Observable that emits true when an item is added to the cart.\n     */\n    onAddToCartEvent() {\n      return this.addToCartSubject.asObservable();\n    }\n    /**\n     * Update the contents of the basket.\n     * @param product the product to update the basket with.\n     * @param productVariant the variant of the product being added.\n     * @param changeQuantity the change in quantity to the product in the basket.\n     *   Defaults to +1\n     */\n    updateBasket(product, productVariant, changeQuantity = 1) {\n      let basketProduct;\n      const basket = this.getBasketFromCookie();\n      if (!basket.hasOwnProperty(productVariant.sku)) {\n        basketProduct = {\n          product,\n          productVariant,\n          quantity: changeQuantity\n        };\n        basket[productVariant.sku] = basketProduct;\n      } else {\n        basket[productVariant.sku].quantity += changeQuantity;\n      }\n      // Remove the item from the basket if the quantity hits 0 or less.\n      if (basket[productVariant.sku].quantity <= 0) {\n        delete basket[productVariant.sku];\n      }\n      this.basket = basket;\n      this.setBasketInCookie(basket);\n    }\n    /**\n     * Buy a product with one-click. Add to the basket and submit order.\n     * @param product the product to buy\n     * @param productVariant the variant of the product being purchased.\n     */\n    buyWithOneClick(product, productVariant) {\n      this.updateBasket(product, productVariant, 1);\n      this.router.navigate(['/thank-you']);\n    }\n    /**\n     * Clear the contents of the basket.\n     */\n    clearBasket() {\n      this.basket = {};\n      this.clearBasketCookie();\n    }\n    /**\n     * Delete the cookie that contains the basket contents.\n     */\n    clearBasketCookie() {\n      this.cookieService.delete(this.cookieName);\n    }\n    /**\n     * Set the contents of the basket in the cookie.\n     */\n    setBasketInCookie(basket) {\n      const cookieProducts = this.parseBasketToCookie(basket);\n      const expiryDate = new Date();\n      expiryDate.setTime(expiryDate.getTime() + this.cookieExpiryDays * 24 * 60 * 60 * 1000);\n      this.cookieService.set(this.cookieName, JSON.stringify(cookieProducts));\n    }\n    /**\n     * Change the contents of the basket into the format stored in the cookie.\n     * @param basket the basket to store in the cookie.\n     * @return an array of BasketProductCookies\n     */\n    parseBasketToCookie(basket) {\n      const cookieProducts = [];\n      for (const basketProduct of Object.values(basket)) {\n        cookieProducts.push({\n          productId: basketProduct.product.id,\n          productVariantSku: basketProduct.productVariant.sku,\n          quantity: basketProduct.quantity\n        });\n      }\n      return cookieProducts;\n    }\n    /**\n     * Change the contents of the basket cookie into a Basket object.\n     * @param cookieProducts the array of products stored in the cookie.\n     * @return the basket object with the contents from the cookie.\n     */\n    parseCookieToBasket(cookieProducts) {\n      const basket = {};\n      for (const cookieProduct of cookieProducts) {\n        const product = this.productsService.products[cookieProduct.productId];\n        const basketProduct = {\n          product,\n          productVariant: product.variants[cookieProduct.productVariantSku],\n          quantity: cookieProduct.quantity\n        };\n        basket[cookieProduct.productVariantSku] = basketProduct;\n      }\n      return basket;\n    }\n    /**\n     * Get the basket contents from the cookie.\n     * @return the basket.\n     */\n    getBasketFromCookie() {\n      const basketJson = this.cookieService.get(this.cookieName);\n      if (basketJson == null || basketJson === '') {\n        return {};\n      } else {\n        try {\n          return this.parseCookieToBasket(JSON.parse(basketJson));\n        } catch (error) {\n          console.error('Error parsing cookie to a basket: ', error);\n          return {};\n        }\n      }\n    }\n    /**\n     * Check to see if the basket is empty.\n     * @return true if the basket is empty, else false\n     */\n    isBasketEmpty() {\n      if (this.basket != null) {\n        return Object.keys(this.basket).length === 0;\n      }\n      return true;\n    }\n    /**\n     * Calculate the basket product price (the price * quantity).\n     * @param basketProduct the basket product.\n     * @param formatAsCurrency set true if you require a currency formatted\n     *   string (e.g. $1,000.00), else false will return a number (e.g. 1000)\n     * @return Either the basket product price as a number or a string.\n     */\n    calculateBasketProductPrice(basketProduct, formatAsCurrency = true) {\n      const total = basketProduct.quantity * basketProduct.productVariant.price;\n      if (formatAsCurrency === false) {\n        return total;\n      }\n      return new Intl.NumberFormat(environment.localCode, {\n        style: 'currency',\n        currency: environment.currency\n      }).format(total);\n    }\n    /**\n     * Calculate the total basket price.\n     * @param formatAsCurrency set true if you require a currency formatted\n     *   string (e.g. $1,000.00), else false will return a number (e.g. 1000)\n     * @return Either the total basket price as a number or a string.\n     */\n    calculateTotalBasketPrice(formatAsCurrency = true) {\n      let total = 0;\n      if (this.basket) {\n        for (const basketProduct of Object.values(this.basket)) {\n          total += this.calculateBasketProductPrice(basketProduct, false);\n        }\n      }\n      if (formatAsCurrency === false) {\n        return total;\n      }\n      return new Intl.NumberFormat(environment.localCode, {\n        style: 'currency',\n        currency: environment.currency\n      }).format(total);\n    }\n    static #_ = this.ɵfac = function BasketService_Factory(t) {\n      return new (t || BasketService)(i0.ɵɵinject(i1.CookieService), i0.ɵɵinject(i2.Router), i0.ɵɵinject(i3.ProductsService));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: BasketService,\n      factory: BasketService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return BasketService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}